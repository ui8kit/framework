import { readFile, writeFileSync, mkdirSync, readdirSync, readFileSync } from 'node:fs';
import { join, dirname, relative } from 'node:path';
import { existsSync } from 'node:fs';

// Import htmlToCss functionality
// Note: We'll copy the core logic here to avoid circular dependencies
// In a real implementation, we might extract htmlToCss into a shared package

interface HtmlConverterOptions {
  verbose?: boolean;
}

interface HtmlToCssConfig {
  htmlDir: string;
  ui8kitMapPath: string;
  applyCssFile: string;
  pureCssFile: string;
  stylesMode?: 'tailwind' | 'css3' | 'css3inline';
  outputHtmlDir?: string;
}

/**
 * Convert HTML snapshots to CSS using the same logic as htmlToCss.ts
 */
export class HtmlConverter {
  private ui8kitMap: Map<string, string> | null = null;
  private config: HtmlToCssConfig | null = null;

  /**
   * Configure the CSS generator
   */
  configure(config: HtmlToCssConfig): HtmlConverter {
    this.config = config;
    return this;
  }

  /**
   * Generate CSS files from HTML
   */
  async generateAll(): Promise<void> {
    if (!this.config) {
      throw new Error('Configuration is required. Call configure() first.');
    }

    const { htmlDir, ui8kitMapPath, applyCssFile, pureCssFile } = this.config;

    console.log(`üîç Scanning HTML files in: ${htmlDir}`);

    // 1. Scan all HTML files and extract element data
    const elements = await this.scanHtmlFiles(htmlDir);
    console.log(`üìÑ Found ${elements.length} styled elements across ${this.getUniqueFiles(elements).length} files`);

    // 2. Group elements by selectors and handle conflicts
    const groupedElements = this.groupBySelectors(elements);
    console.log(`üéØ Generated ${groupedElements.size} unique selectors`);

    // 3. Load ui8kit map for pure CSS generation
    const mapPath = ui8kitMapPath;
    const ui8kitMap = await this.loadUi8kitMapForPath(mapPath);
    console.log(`üìö Loaded ${ui8kitMap.size} CSS mappings from ${mapPath}`);

    const stylesMode = this.config.stylesMode || 'tailwind';

    if (stylesMode === 'css3inline') {
      // Generate inline styles for head
      await this.processCss3InlineMode(groupedElements, ui8kitMap);
      console.log('‚úÖ Processed CSS3 inline mode - styles injected into HTML head');
    } else {
      // Generate external CSS files
      if (stylesMode === 'tailwind') {
        // Tailwind mode: classes stay in HTML, no external CSS needed
        console.log('‚úÖ Tailwind mode: classes preserved in HTML, no external CSS generated');
      } else if (stylesMode === 'css3') {
        // Generate both apply CSS (for Tailwind processor) and pure CSS3
        const applyCss = this.generateApplyCss(groupedElements);
        this.writeCssFile(applyCssFile, applyCss);
        console.log(`‚úÖ Generated ${applyCssFile} (${applyCss.length} bytes)`);

        const pureCss = this.generatePureCss(groupedElements, ui8kitMap);
        this.writeCssFile(pureCssFile, pureCss);
        console.log(`‚úÖ Generated ${pureCssFile} (${pureCss.length} bytes)`);
      }

      // Process HTML files based on mode (remove class attributes for css3)
      await this.processHtmlFilesForMode(stylesMode);
    }

    console.log('üéâ CSS generation completed!');
  }

  /**
   * Convert HTML file to CSS files
   */
  async convertHtmlToCss(
    htmlFilePath: string,
    outputApplyCss: string,
    outputPureCss: string,
    options: HtmlConverterOptions = {}
  ): Promise<{ applyCss: string; pureCss: string }> {
    const { verbose = false } = options;

    if (verbose) {
      console.log(`üîÑ Converting HTML to CSS: ${htmlFilePath}`);
    }

    // Load ui8kit map
    await this.loadUi8kitMap(htmlFilePath);

    // Extract elements from HTML
    const html = await readFile(htmlFilePath, 'utf-8');
    const elements = this.extractElementsFromHtml(html, htmlFilePath);

    if (verbose) {
      console.log(`üìÑ Found ${elements.length} elements with classes`);
    }

    // Group by selectors
    const groupedElements = this.groupBySelectors(elements);

    // Generate CSS
    const applyCss = this.generateApplyCss(groupedElements);
    const pureCss = this.generatePureCss(groupedElements);

    return { applyCss, pureCss };
  }

  /**
   * Load ui8kit map for CSS property lookups (for convertHtmlToCss method)
   */
  private async loadUi8kitMap(htmlFilePath: string): Promise<void> {
    // Find ui8kit.map.json - try multiple locations
    const possiblePaths = [
      join(dirname(htmlFilePath), '../../../local/src/lib/ui8kit.map.json'),
      join(dirname(htmlFilePath), '../../../../apps/local/src/lib/ui8kit.map.json'),
      './apps/local/src/lib/ui8kit.map.json'
    ];

    let jsonContent: string | null = null;
    let foundPath: string | null = null;

    for (const mapPath of possiblePaths) {
      try {
        jsonContent = await readFile(mapPath, 'utf-8');
        foundPath = mapPath;
        break;
      } catch {
        // Try next path
      }
    }

    if (!jsonContent || !foundPath) {
      throw new Error(`Could not find ui8kit.map.json. Tried: ${possiblePaths.join(', ')}`);
    }

    try {
      const ui8kitMapObject = JSON.parse(jsonContent);

      this.ui8kitMap = new Map<string, string>();
      for (const [key, value] of Object.entries(ui8kitMapObject)) {
        this.ui8kitMap.set(key, value as string);
      }
    } catch (error) {
      throw new Error(`Failed to parse ui8kit.map.json from ${foundPath}: ${error}`);
    }
  }

  /**
   * Load ui8kit map for CSS property lookups (for convertHtmlToCss method)
   */
  private async loadUi8kitMapForPath(mapPath: string): Promise<Map<string, string>> {
    try {
      // Try JSON first (preferred)
      const jsonPath = mapPath.replace(/\.ts$/, '.json');
      const jsonContent = readFileSync(jsonPath, 'utf-8');
      const ui8kitMapObject = JSON.parse(jsonContent);

      // Convert object to Map
      const ui8kitMap = new Map<string, string>();
      for (const [key, value] of Object.entries(ui8kitMapObject)) {
        ui8kitMap.set(key, value as string);
      }

      return ui8kitMap;
    } catch (error) {
      // Fallback to TypeScript parsing if JSON fails
      return this.loadUi8kitMapFallback(mapPath);
    }
  }

  /**
   * Fallback method for TypeScript parsing (kept for compatibility)
   */
  private loadUi8kitMapFallback(mapPath: string): Map<string, string> {
    // Simplified fallback - just throw error since we prefer JSON
    throw new Error(`JSON import failed and TypeScript fallback is not available. Please ensure ${mapPath.replace('.ts', '.json')} exists.`);
  }

  /**
   * Recursively scan HTML files and extract element data
   */
  private async scanHtmlFiles(dir: string): Promise<ElementData[]> {
    const elements: ElementData[] = [];
    const files = this.getHtmlFiles(dir);

    for (const file of files) {
      const fileElements = this.extractElementsFromHtml(readFileSync(file, 'utf-8'), file);
      elements.push(...fileElements);
    }

    return elements;
  }

  /**
   * Get all HTML files recursively
   */
  private getHtmlFiles(dir: string): string[] {
    const files: string[] = [];

    function scan(currentDir: string) {
      const entries = readdirSync(currentDir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = join(currentDir, entry.name);

        if (entry.isDirectory()) {
          scan(fullPath); // Recursive scan
        } else if (entry.isFile() && entry.name.endsWith('.html')) {
          files.push(fullPath);
        }
      }
    }

    scan(dir);
    return files;
  }

  /**
   * Load ui8kit map for CSS property lookups (for generateAll method)
   */
  private async loadUi8kitMapForPath(mapPath: string): Promise<Map<string, string>> {
    // Find ui8kit.map.json - try multiple locations
    const possiblePaths = [
      join(dirname(htmlFilePath), '../../../local/src/lib/ui8kit.map.json'),
      join(dirname(htmlFilePath), '../../../../apps/local/src/lib/ui8kit.map.json'),
      './apps/local/src/lib/ui8kit.map.json'
    ];

    let jsonContent: string | null = null;
    let foundPath: string | null = null;

    for (const mapPath of possiblePaths) {
      try {
        jsonContent = await readFile(mapPath, 'utf-8');
        foundPath = mapPath;
        break;
      } catch {
        // Try next path
      }
    }

    if (!jsonContent || !foundPath) {
      throw new Error(`Could not find ui8kit.map.json. Tried: ${possiblePaths.join(', ')}`);
    }

    try {
      const ui8kitMapObject = JSON.parse(jsonContent);

      this.ui8kitMap = new Map<string, string>();
      for (const [key, value] of Object.entries(ui8kitMapObject)) {
        this.ui8kitMap.set(key, value as string);
      }
    } catch (error) {
      throw new Error(`Failed to parse ui8kit.map.json from ${foundPath}: ${error}`);
    }
  }

  /**
   * Extract elements with classes from HTML
   */
  private extractElementsFromHtml(html: string, sourceFile: string): ElementData[] {
    const elements: ElementData[] = [];

    // Simple regex to find tags with class or data-class attributes
    const tagRegex = /<[^>]+>/g;
    let match;

    while ((match = tagRegex.exec(html)) !== null) {
      const tagContent = match[0];

      const classes = this.extractClassAttribute(tagContent);
      const dataClass = this.extractDataClassAttribute(tagContent);

      if (classes.length > 0 || dataClass) {
        elements.push({
          selector: dataClass || this.generateSelector(tagContent),
          classes,
          sourceFile
        });
      }
    }

    return elements;
  }

  /**
   * Extract class attribute values (not data-class)
   */
  private extractClassAttribute(tagContent: string): string[] {
    // Use a more precise regex that finds class= but not data-class=
    const classRegex = /\s+class\s*=\s*["']([^"']*)["']/;
    const classMatch = tagContent.match(classRegex);
    if (!classMatch) return [];

    const classValue = classMatch[1];
    const classes = classValue.split(/\s+/).filter(cls => cls.trim());
    return classes;
  }

  /**
   * Extract data-class attribute value
   */
  private extractDataClassAttribute(tagContent: string): string {
    const dataClassMatch = tagContent.match(/data-class\s*=\s*["']([^"']*)["']/);
    return dataClassMatch ? dataClassMatch[1].trim() : '';
  }

  /**
   * Generate selector for elements without data-class
   */
  private generateSelector(tagContent: string): string {
    const tagMatch = tagContent.match(/^<([a-zA-Z][a-zA-Z0-9]*)/);
    const tagName = tagMatch ? tagMatch[1] : 'div';

    // Generate random suffix
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let suffix = '';
    for (let i = 0; i < 7; i++) {
      suffix += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return `${tagName}-${suffix}`;
  }

  /**
   * Group elements by data-class selectors and collect all their classes
   */
  private groupBySelectors(elements: ElementData[]): Map<string, string[]> {
    const selectorMap = new Map<string, string[]>();

    for (const element of elements) {
      const selector = element.selector;
      const classes = element.classes;

      // Skip elements without classes
      if (classes.length === 0) continue;

      // Add classes to existing selector or create new one
      const existingClasses = selectorMap.get(selector) || [];
      const allClasses = [...existingClasses, ...classes];

      // Remove duplicates
      const uniqueClasses = [...new Set(allClasses)];
      selectorMap.set(selector, uniqueClasses);
    }

    return selectorMap;
  }

  /**
   * Normalize classes by sorting
   */
  private normalizeClasses(classes: string[]): string[] {
    return [...classes].sort();
  }

  /**
   * Generate @apply CSS
   */
  private generateApplyCss(selectorMap: Map<string, string[]>): string {
    const cssRules: string[] = [];
    const sortedSelectors = Array.from(selectorMap.keys()).sort();

    for (const selector of sortedSelectors) {
      const classes = selectorMap.get(selector) || [];
      if (classes.length > 0) {
        cssRules.push(`.${selector} {\n  @apply ${classes.join(' ')};\n}`);
      }
    }

    const header = `/*
 * Generated by UI8Kit CSS Preprocessor - @apply directives
 * Do not edit manually - this file is auto-generated
 * Generated on: ${new Date().toISOString()}
 */\n\n`;

    return header + cssRules.join('\n\n') + '\n';
  }

  /**
   * Generate pure CSS3
   */
  private generatePureCss(selectorMap: Map<string, string[]>): string {
    const cssRules: string[] = [];
    const sortedSelectors = Array.from(selectorMap.keys()).sort();

    for (const selector of sortedSelectors) {
      const classes = selectorMap.get(selector) || [];
      const cssProperties: string[] = [];

      for (const className of classes) {
        const cssProperty = this.ui8kitMap?.get(className);
        if (cssProperty) {
          cssProperties.push(`  ${cssProperty}`);
        } else {
          cssProperties.push(`  /* Unknown class: ${className} */`);
        }
      }

      if (cssProperties.length > 0) {
        cssRules.push(`.${selector} {\n${cssProperties.join('\n')}\n}`);
      }
    }

    const header = `/*
 * Generated by UI8Kit CSS Preprocessor - Pure CSS3 properties
 * Do not edit manually - this file is auto-generated
 * Generated on: ${new Date().toISOString()}
 */\n\n`;

    return header + cssRules.join('\n\n') + '\n';
  }

  /**
   * Process HTML files based on styles mode
   */
  private async processHtmlFilesForMode(mode: 'tailwind' | 'css3' | 'css3inline'): Promise<void> {
    if (mode === 'tailwind') {
      // No changes needed for tailwind mode
      return;
    }

    const htmlFiles = this.getHtmlFiles(this.config!.htmlDir);
    const outputDir = this.config!.outputHtmlDir;

    for (const filePath of htmlFiles) {
      let htmlContent = readFileSync(filePath, 'utf-8');

      if (mode === 'css3') {
        // Remove class attributes, keep only data-class
        htmlContent = this.removeClassAttributes(htmlContent);
      }

      // Write to output directory if specified, otherwise modify in place
      const targetPath = outputDir ? this.getOutputPath(filePath, outputDir) : filePath;
      if (outputDir) {
        this.ensureDir(dirname(targetPath));
      }

      writeFileSync(targetPath, htmlContent, 'utf-8');
    }

    console.log(`‚úÖ Processed ${htmlFiles.length} HTML files for ${mode} mode${outputDir ? ` ‚Üí ${outputDir}` : ''}`);
  }

  /**
   * Process CSS3 inline mode - inject styles into HTML head
   */
  private async processCss3InlineMode(groupedElements: Map<string, string[]>, ui8kitMap: Map<string, string>): Promise<void> {
    const htmlFiles = this.getHtmlFiles(this.config!.htmlDir);
    const outputDir = this.config!.outputHtmlDir;
    const pureCss = this.generatePureCss(groupedElements, ui8kitMap);

    // Minify CSS for inline injection
    const minifiedCss = this.minifyCss(pureCss);

    for (const filePath of htmlFiles) {
      let htmlContent = readFileSync(filePath, 'utf-8');

      // Remove class attributes, keep only data-class
      htmlContent = this.removeClassAttributes(htmlContent);

      // Inject inline styles into head
      htmlContent = this.injectInlineStyles(htmlContent, minifiedCss);

      // Write to output directory if specified, otherwise modify in place
      const targetPath = outputDir ? this.getOutputPath(filePath, outputDir) : filePath;
      if (outputDir) {
        this.ensureDir(dirname(targetPath));
      }

      writeFileSync(targetPath, htmlContent, 'utf-8');
    }

    console.log(`‚úÖ Injected ${minifiedCss.length} bytes of CSS into ${htmlFiles.length} HTML files${outputDir ? ` ‚Üí ${outputDir}` : ''}`);
  }

  /**
   * Remove class attributes from HTML, keep data-class
   */
  private removeClassAttributes(htmlContent: string): string {
    // Remove class="..." attributes but keep data-class
    return htmlContent.replace(/\s+class\s*=\s*["'][^"']*["']/g, '');
  }

  /**
   * Inject inline styles into HTML head
   */
  private injectInlineStyles(htmlContent: string, css: string): string {
    const styleTag = `<style>${css}</style>`;

    // Insert before closing </head>
    return htmlContent.replace('</head>', `  ${styleTag}\n  </head>`);
  }

  /**
   * Simple CSS minification
   */
  private minifyCss(css: string): string {
    return css
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
      .replace(/\s+/g, ' ') // Collapse whitespace
      .replace(/\s*{\s*/g, '{') // Remove spaces around braces
      .replace(/\s*}\s*/g, '}') // Remove spaces around closing braces
      .replace(/\s*;\s*/g, ';') // Remove spaces around semicolons
      .replace(/;\s*}/g, '}') // Remove trailing semicolons
      .trim();
  }

  /**
   * Write CSS file with directory creation
   */
  private writeCssFile(filePath: string, content: string): void {
    const dir = dirname(filePath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    writeFileSync(filePath, content, 'utf-8');
  }

  /**
   * Get output path for HTML file in output directory
   */
  private getOutputPath(inputPath: string, outputDir: string): string {
    const relativePath = relative(this.config!.htmlDir, inputPath);
    return join(outputDir, relativePath);
  }

  /**
   * Ensure directory exists
   */
  private ensureDir(dirPath: string): void {
    if (!existsSync(dirPath)) {
      mkdirSync(dirPath, { recursive: true });
    }
  }

  /**
   * Get count of unique source files
   */
  private getUniqueFiles(elements: ElementData[]): number {
    return new Set(elements.map(el => el.sourceFile)).size;
  }
}

interface ElementData {
  selector: string;
  classes: string[];
  sourceFile: string;
}

// Export singleton instance
export const htmlConverter = new HtmlConverter();
